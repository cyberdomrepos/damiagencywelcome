## NavBar Developer Guide

This guide explains `app/components/NavBar.tsx` (the site's responsive navigation) for beginner → intermediate developers, and gives concrete, prioritized improvements to make it behave like a production-ready UX component.

File: `app/components/NavBar.tsx`

---

## What this component does (high level)

- Renders a fixed header/nav at the top of the page.
- Shows a centered desktop menu (hidden on small screens), a right-side CTA, and a mobile toggle that opens a dropdown menu.
- Tracks scroll position to change the header background for better contrast while scrolling.
- Provides ARIA attributes such as `aria-expanded`, `aria-controls`, and `aria-current` for basic accessibility.

## Inputs, outputs, and success criteria (contract)

- Inputs: none (no props). Uses internal React state.
- Internal state:
  - `open` (boolean): whether the mobile menu is open.
  - `scrolled` (boolean): whether the page has scrolled beyond a threshold.
  - `menuId` (string): a stable id generated by `useId()` for aria relationships.
- Output: markup for header/nav that should be responsive, keyboard-accessible, and readable.
- Success criteria:
  - Desktop menu visible and accessible.
  - Mobile menu toggles open/closed, is keyboard accessible, and prevents background scrolling.
  - Visual contrast and focus indicators meet WCAG guidance.

## Walkthrough — key sections explained

1. "use client"

   The component uses browser APIs and React hooks. For Next.js app router, adding `"use client"` ensures the component runs in the browser.

2. Hooks and state

   - `useState(false)` for `open` and `scrolled`.
   - `useId()` to produce `menuId` used by the toggle button's `aria-controls` and the mobile menu's `id`.

3. Scroll listener (`useEffect`)

   - Adds a `scroll` listener which updates `scrolled` when `window.scrollY > 30`.
   - This toggles the header background so nav stays legible when content scrolls under it.
   - Optimization: the handler should be throttled (see improvements) to avoid re-render thrash.

4. `MENU` configuration

   - An in-component array with `{ href, label, primary?, ariaLabel? }` used to render both desktop and mobile menus.
   - `primary` marks the CTA which is shown separately on the right.

5. Desktop menu (centered)

   - Hidden on small screens (`hidden md:block`).
   - Uses `aria-current` for the home link.
   - Applies `nav-link-underline` utility for hover underline on non-home links.

6. Right side — CTA and mobile toggle

   - CTA is visible on medium+ screens.
   - Toggle button manages `open` and sets `aria-expanded` and `aria-controls` accordingly. SVG shows hamburger vs close icon.

7. Mobile dropdown

   - The dropdown is controlled by `open`. It uses Tailwind classes for show/hide and animation.
   - Menu items include a per-item `transitionDelay` for a staggered reveal.

## Accessibility (what's good and what to improve)

What's already good:

- Uses `aria-expanded` and `aria-controls` to link the toggle to the menu.
- `aria-current` used for the current link (Home), and `aria-label` present on links.

Gaps and recommendations:

- Focus management: When menu opens, focus should move into the menu (to the first link) and return to the toggle when menu closes.
- Focus trap: When the mobile menu is open, keyboard focus should be trapped inside the menu until it is closed.
- Escape handling: Allow closing the menu with the Escape key.
- Body scroll lock: Prevent page scroll behind the open mobile menu.
- Contrast & hit targets: Ensure interactive elements are large enough (44×44px) and meet color contrast guidelines.
- Reduced motion: Respect `prefers-reduced-motion` for users who disable motion.

## UX improvements (prioritized)

High priority (do these first):

1. Focus management + return focus

   - Move focus to the first link when the mobile menu opens.
   - When menu closes, return focus to the toggle button.

2. Escape key to close

   - Add a `keydown` listener to close the menu when Escape is pressed.

3. Body scroll lock
   - Prevent the page behind the open mobile menu from scrolling.

Medium priority:

4. Focus trap

   - Implement a focus trap (or use a small library such as `focus-trap` or `focus-trap-react`).

5. Optimize scroll event handling

   - Use `requestAnimationFrame` or a tiny throttle to avoid performance issues when tracking `window.scrollY`.

6. Active link highlight while scrolling
   - Use `IntersectionObserver` to set an `active` item based on which section is currently visible.

Lower priority / polish:

7. respects `prefers-reduced-motion` using `motion-safe`/`motion-reduce` or CSS media queries.
8. Move `MENU` config to a separate file and memoize if you add props later.

## Concrete code patterns (copy/paste friendly)

Below are small, self-contained snippets you can drop into `NavBar.tsx` to implement the most impactful improvements.

### 1) Escape key + body scroll lock + focus move

Add refs and this effect inside the component, near the state definitions:

```tsx
import { useEffect, useRef } from "react";

const toggleButtonRef = useRef<HTMLButtonElement | null>(null);
const firstMenuRef = useRef<HTMLAnchorElement | null>(null);

useEffect(() => {
  if (!open) return;

  // lock scrolling
  const prevOverflow = document.body.style.overflow;
  document.body.style.overflow = "hidden";

  // move focus to first item
  firstMenuRef.current?.focus();

  const onKey = (e: KeyboardEvent) => {
    if (e.key === "Escape") setOpen(false);
  };
  window.addEventListener("keydown", onKey);
  return () => {
    window.removeEventListener("keydown", onKey);
    document.body.style.overflow = prevOverflow; // restore
    // return focus to toggle
    toggleButtonRef.current?.focus();
  };
}, [open]);

// Then:
// - Add ref={toggleButtonRef} to the toggle <button>
// - Add ref={firstMenuRef} to the first mobile link (<a ... ref={firstMenuRef} />)
```

This gives immediate UX improvements: keyboard users can close with Escape, the menu prevents background scroll, and focus is managed.

### 2) requestAnimationFrame for scroll performance

Replace the basic scroll listener with a rAF approach:

```tsx
useEffect(() => {
  let ticking = false;
  const onScroll = () => {
    if (!ticking) {
      window.requestAnimationFrame(() => {
        setScrolled(window.scrollY > 30);
        ticking = false;
      });
      ticking = true;
    }
  };
  window.addEventListener("scroll", onScroll, { passive: true });
  return () => window.removeEventListener("scroll", onScroll);
}, []);
```

This is low-cost and reduces layout thrash on long scrolls.

### 3) Active link tracking with IntersectionObserver (basic)

```tsx
useEffect(() => {
  let observer: IntersectionObserver | null = null;
  const ids = ["home", "services", "portfolio", "about", "quote"];
  const setActive = (id: string) => {
    /* set active state */
  };

  observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) setActive(`#${entry.target.id}`);
      });
    },
    { threshold: 0.4 }
  );

  ids.forEach((id) => {
    const el = document.getElementById(id);
    if (el) observer!.observe(el);
  });

  return () => observer?.disconnect();
}, []);
```

Use the `active` state to set `aria-current={active === m.href ? 'page' : undefined}` and add a visual style.

### 4) Lightweight focus trap idea (simple)

For a minimal trap, capture Tab/Shift+Tab and loop focus between first and last items. For production, prefer `focus-trap` lib.

```tsx
useEffect(() => {
  if (!open) return;
  const focusable = Array.from(
    document.querySelectorAll("#" + menuId + " a, #" + menuId + " button")
  ) as HTMLElement[];
  const first = focusable[0];
  const last = focusable[focusable.length - 1];

  const handleTab = (e: KeyboardEvent) => {
    if (e.key !== "Tab") return;
    if (e.shiftKey && document.activeElement === first) {
      e.preventDefault();
      last.focus();
    } else if (!e.shiftKey && document.activeElement === last) {
      e.preventDefault();
      first.focus();
    }
  };

  window.addEventListener("keydown", handleTab);
  return () => window.removeEventListener("keydown", handleTab);
}, [open, menuId]);
```

## Testing checklist

- Keyboard navigation: toggle button focusable, toggle opens menu with Enter/Space, Tab cycles menu items, Escape closes and returns focus.
- Screen reader: toggle announces `expanded` state; links announce labels and active state.
- Mobile: background scroll locked when menu open.
- Visual: focus outline clearly visible; contrast ratios meet WCAG AA.

## How to validate locally (commands)

Run the dev server and test manually in a browser:

```bash
# from repo root
npm install
npm run dev
```

Run a production build (to ensure no Next/TS errors):

```bash
npm run build
```

Optional: run an accessibility audit (Lighthouse) in Chrome DevTools or use `axe` / `pa11y`.

## Additional references & libraries

- `focus-trap` / `focus-trap-react` — robust focus trapping and a11y utilities.
- `body-scroll-lock` — utilities to prevent background scrolling on mobile (be mindful of Safari bounce quirks).
- MDN docs on `IntersectionObserver` and `requestAnimationFrame`.

## Suggested rollout plan (small, safe steps)

1. Implement Escape + focus move + body scroll lock (small change, high impact).
2. Replace scroll handler with rAF throttle.
3. Add active-link IntersectionObserver and wire `aria-current` dynamically.
4. Add focus trap (library) and tests.
5. Run Lighthouse and address accessibility issues found.

## Closing notes

Start with the Escape + focus + scroll-lock changes — they are small, low-risk, and immediately improve keyboard and mobile UX. After that, the IntersectionObserver active-link highlight is a visible UX improvement.

If you want, I can implement step 1 now as a small patch and run the build/test cycle. Which step should I do next?
